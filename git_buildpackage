#!/usr/bin/env python
#
# (C) 2014 by Jan Blunck <jblunck@infradead.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# See http://www.gnu.org/licenses/gpl-2.0.html for full license text.

import argparse
import datetime
import os
import shutil
import re
import fnmatch
import sys
import tarfile
import subprocess
import atexit
import hashlib
import tempfile
import logging
import glob
import ConfigParser
import StringIO


CLEANUP_DIRS = []

BUILD_ARGS = '--git-cleaner="true" -nc -uc -us -S'

def cleanup(dirs):
    '''Cleaning temporary directories.'''

    logging.info("Cleaning: %s", ' '.join(dirs))

    for d in dirs:
        if not os.path.exists(d):
            continue
        shutil.rmtree(d)


def safe_run(cmd, cwd, interactive=False):
    """Execute the command cmd in the working directory cwd and check return
    value. If the command returns non-zero raise a SystemExit exception."""

    logging.debug("COMMAND: %s", cmd)

    # Ensure we get predictable results when parsing the output of commands
    # like 'git branch'
    env = os.environ.copy()
    env['LANG'] = 'C'

    proc = subprocess.Popen(cmd,
                            shell=False,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT,
                            cwd=cwd,
                            env=env)
    output = ''
    if interactive:
        stdout_lines = []
        while proc.poll() is None:
            for line in proc.stdout:
                print line.rstrip()
                stdout_lines.append(line.rstrip())
        output = '\n'.join(stdout_lines)
    else:
        output = proc.communicate()[0]

    logging.debug("RESULT(%d): %s", proc.returncode, repr(output))

    if proc.returncode:
        sys.exit("ERROR(%d): %s:\n%s" % (proc.returncode, ' '.join(cmd), repr(output)))

    return (proc.returncode, output)


def switch_revision(clone_dir, revision):
    """Switch sources to revision. The GIT revision may refer to any of the
    following:
    - explicit SHA1: a1b2c3d4....
    - the SHA1 must be reachable from a default clone/fetch (generally, must be
      reachable from some branch or tag on the remote).
    - short branch name: "master", "devel" etc.
    - explicit ref: refs/heads/master, refs/tags/v1.2.3,
      refs/changes/49/11249/1
    """

    if revision is None:
        revision = 'master'

    revs = [x + revision for x in ['origin/', '']]
    for rev in revs:
        try:
            safe_run(['git', 'rev-parse', '--verify', '--quiet', rev],
                     cwd=clone_dir)
            text = safe_run(['git', 'reset', '--hard', rev], cwd=clone_dir)[1]
            revision = rev
            print text.rstrip()
            break
        except SystemExit:
            continue
    else:
        sys.exit('%s: No such revision' % revision)

    return revision


def fetch_upstream(url, revision, out_dir):
    """Fetch sources from repository and checkout given revision."""

    # calc_dir_to_clone_to
    basename = os.path.basename(re.sub(r'/.git$', '', url))
    clone_dir = os.path.abspath(os.path.join(out_dir, basename))

    if not os.path.isdir(clone_dir):
        # initial clone
        os.mkdir(clone_dir)

        safe_run(['git', 'clone', '--no-checkout', url, clone_dir],
                 cwd=out_dir, interactive=sys.stdout.isatty())
#        safe_run(['git', 'submodule', 'update', '--init', '--recursive'],
#                 cwd=clone_dir)
    else:
        logging.info("Detected cached repository...")
#        UPDATE_CACHE_COMMANDS[scm](url, clone_dir, revision)

    return clone_dir


def create_source_package(repo_dir, output_dir, revision, build_args, url,
                          append_git_id, append_git_url):
    """Create source package via git-buildpackage"""
    absoutput_dir = os.path.abspath(output_dir)

    if not revision:
        revision = 'master'

    """ We are about to create a snapshot build from our git repo.
        Make sure we record the git-id of the snapshot """
    git_show_output = safe_run(['git', 'rev-parse', 'HEAD'],
                               cwd=clone_dir,
                               interactive=sys.stdout.isatty())
    git_id = str(git_show_output[1]).rstrip('\n')

    """ Do we want to add the GitId and GitUrl to package """
    git_options = ['both', 'source', 'binary']
    git_id_option_set = append_git_id in git_options
    git_url_option_set = append_git_url in git_options

    if git_id_option_set or git_url_option_set:
        content = None

        """ Open the Control file in the clone """
        debian_dir = os.path.join(repo_dir, 'debian')
        control_fname = os.path.join(debian_dir, 'control')
        try:
            control_file = open(control_fname, 'r')
        except IOError:
            logging.error('Error reading control file : \'' +
                          control_fname + '\'')
            sys.exit(0)
        else:
            with control_file:
                content = control_file.readlines()
                for i, line in enumerate(content):
                    if line == '\r\n' or line == '\n':
                        if git_id_option_set:
                            if append_git_id == 'both':
                                x_string = 'XBS'
                            elif append_git_id == 'source':
                                x_string = 'XS'
                            else:
                                x_string = 'XB'

                            content.insert(i, x_string + '-Git-Id: ' +
                                           git_id + '\n')
                            logging.info('Appending \'' + control_fname +
                                         '\' with : \'' + x_string +
                                         '-Git-Id: ' + git_id + '\'')
                            i = i + 1

                        if git_url_option_set:
                            if append_git_url == 'both':
                                x_string = 'XBS'
                            elif append_git_url == 'source':
                                x_string = 'XS'
                            else:
                                x_string = 'XB'

                            content.insert(i, x_string + '-Git-Url: ' +
                                           url + '\n' )
                            logging.info('Appending \'' + control_fname +
                                         '\' with : \'' + x_string +
                                         '-Git-Url: ' +
                                         url + '\'')
                            i = i + 1
                        break
        if content:
            """ Write new tags to control file in local clone """
            try:
                control_file = open(control_fname, 'w')
            except IOError:
                logging.error('Error writing to control file : \'' +
                              control_fname + '\'')
                sys.exit(0)
            else:
                with control_file:
                    control_file.writelines(content)

            """ Commit to local clone debian/control tag additions """
            safe_run(['git', 'commit', '-a', '-m',
                      'Add Git-Id/Git-Url to control'], cwd=repo_dir)

    """ Prepare git buildpackage """
    command = ['git', 'buildpackage', '--git-notify=off', '--git-force-create']

#   command.append('--git-verbose')
    # we are not on a proper local branch due to using git-reset but we anyway
    # use the --git-export option
    command.extend(['--git-ignore-branch',
                    "--git-export-dir=%s" % absoutput_dir])

    # create local pristine-tar branch
    try:
        safe_run(['git', 'rev-parse', '--verify', '--quiet',
                  'origin/pristine-tar'], cwd=repo_dir)
        safe_run(['git', 'update-ref', 'refs/heads/pristine-tar',
                  'origin/pristine-tar'], cwd=repo_dir)
        command.append('--git-pristine-tar')
    except SystemExit:
        command.append('--git-no-pristine-tar')

    command.extend(BUILD_ARGS.split(' '))

    logging.debug("Running in %s", repo_dir)

    # Since gbp is the "heart" of this service lets force interactive mode
    safe_run(command, cwd=repo_dir, interactive=True)

def copy_source_package(input_dir, output_dir):
    """Copy Debian sources found in input_dir to output_dir."""
    input_dir = os.path.abspath(input_dir)
    sources = safe_run(['dpkg-scansources', input_dir], cwd=input_dir)[1]

    FILES_PATTERN = re.compile(r'^Files:(.*(?:\n .*)+)', flags=re.MULTILINE)
    for match in FILES_PATTERN.findall(sources):
        logging.info("Files:")
        for line in match.strip().split("\n"):
            fname = line.strip().split(' ')[2]
            logging.info(" %s", fname)
            input_file = os.path.join(input_dir, fname)
            output_file = os.path.join(output_dir, fname)

            if (args.dch_release_update and fnmatch.fnmatch(fname, '*.dsc')):
               with open(input_file, "a") as dsc_file:
                   dsc_file.write("OBS-DCH-RELEASE: 1")

            shutil.copy(input_file, output_file)


if __name__ == '__main__':
    FORMAT = "%(message)s"
    logging.basicConfig(format=FORMAT, stream=sys.stderr, level=logging.INFO)

    parser = argparse.ArgumentParser(description='Git Tarballs')
    parser.add_argument("--config",
                        default='/etc/obs/services/git_buildpackage',
                        help="Specify config file", metavar="FILE")
    args, remaining_argv = parser.parse_known_args()
    defaults = dict({
        'verbose': False
    })
    if os.path.isfile(args.config):
        logging.info("Reading configuration file %s", args.config)
        configfp = StringIO.StringIO()
        configfp.write('[DEFAULT]\n')
        configfp.write(open(args.config).read())
        configfp.seek(0, os.SEEK_SET)
        config = ConfigParser.SafeConfigParser(defaults)
        config.readfp(configfp)
        defaults = dict(config.defaults())

    parser.set_defaults(**defaults)
    parser.add_argument('--url', required=True,
                        help='upstream tarball URL to download')
    parser.add_argument('--revision',
                        help='revision to package')
    parser.add_argument('--submodules',
                        help='osc service parameter that does nothing')
    parser.add_argument('--outdir', required=True,
                        help='osc service parameter that does nothing')
    parser.add_argument('--build_args',
                        help='osc service parameter that does nothing')
    parser.add_argument('--pristine-tar',
                        help='osc service parameter that does nothing')
    parser.add_argument('--dch-release-update', choices=['enable', 'disable'],
                        default='disable',
                        help='Append OBS release number')
    parser.add_argument('--gitid', choices=['source', 'binary', 'both'],
                        help='Append Git-Id')
    parser.add_argument('--giturl', choices=['source', 'binary', 'both'],
                        help='Append Git-URL')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='enable verbose output')

    args = parser.parse_args(remaining_argv)

    # force verbose mode in test-mode
    if os.getenv('DEBUG_GIT_BUILDPACKAGE'):
        args.verbose = True

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    if args.dch_release_update == 'enable':
        args.dch_release_update = True
    else:
        args.dch_release_update = False

    if not args.gitid in [None, 'source', 'binary', 'both']:
        sys.exit('Error, config option \'gitid:\' has invalid argument \'' +
                 str(args.gitid) +
                 '\', valid options include [None, both, source, binary]')

    if not args.giturl in [None, 'source', 'binary', 'both']:
        sys.exit('Error, config option \'giturl:\' has invalid argument \'' +
                 str(args.giturl) +
                 '\', valid options include [None, both, source, binary]')

    #
    # real main
    #

    # force cleaning of our workspace on exit
    atexit.register(cleanup, CLEANUP_DIRS)

    repodir = None

    # create_dirs
    if repodir is None:
        repodir = tempfile.mkdtemp(dir=args.outdir)
        CLEANUP_DIRS.append(repodir)

    # initial_clone
    clone_dir = fetch_upstream(args.url, args.revision, repodir)

    # switch_to_revision
    revision = switch_revision(clone_dir, args.revision)

    # create_source_package
    create_source_package(clone_dir, args.outdir, revision=revision,
                          build_args=args.build_args, url=args.url,
                          append_git_id=args.gitid,
                          append_git_url=args.giturl)

    # copy_source_package
    copy_source_package(repodir, args.outdir)
